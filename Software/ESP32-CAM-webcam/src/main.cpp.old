#include "OV2640.h"
#include <WiFi.h>
#include <WiFiClient.h>

#include "SimStreamer.h"
#include "OV2640Streamer.h"
#include "OV2640.h"
#include "CRtspSession.h"

#include <PsychicHttp.h>
#include <ElegantOTA.h>

#include "MultiClientHandler.h" // Simpler extension of a PsychicHttpHandler to help us manage multiple clients

#include <Preferences.h>

PsychicWebSocketHandler websocketHandler;
PsychicEventSource eventSource;
PsychicHttpServer server;


// This is the ESP32 library that gives us access to the onboard EEPROM / Flash
Preferences preferences;


// Based on https://github.com/geeksville/TenDollarWebcam/blob/master/src/ESP32-devcam.ino

 #define USEBOARD_AITHINKER


// #define SOFTAP_MODE // If you want to run our own softap turn this on
#define ENABLE_WEBSERVER
#define ENABLE_RTSPSERVER

OV2640 cam;

// #ifdef ENABLE_WEBSERVER
// WebServer server(80);
// #endif

#ifdef ENABLE_RTSPSERVER
WiFiServer rtspServer(8554);
#endif


unsigned long ota_progress_millis = 0;

void onOTAStart() {
  // Log when OTA has started
  Serial.println("OTA update started!");
  // <Add your own code here>
}

void onOTAProgress(size_t current, size_t final) {
  // Log every 1 second
  if (millis() - ota_progress_millis > 1000) {
    ota_progress_millis = millis();
    Serial.printf("OTA Progress Current: %u bytes, Final: %u bytes\n", current, final);
  }
}

void onOTAEnd(bool success) {
  // Log when OTA has finished
  if (success) {
    Serial.println("OTA update finished successfully!");
  } else {
    Serial.println("There was an error during OTA update!");
  }
  // <Add your own code here>
}



esp_err_t handle_jpg_stream(PsychicRequest *request)
{
  Serial.println("jpgstream");
  cam.run();

  PsychicResponse response(request);
  response.setCode(200);
  response.setContentType("image/jpeg");

  //add our actual content
  response.setContent((const uint8_t *)cam.getfb(), cam.getSize());
  return response.send();
    
  // WiFiClient client = server.client();
  // String response = "HTTP/1.1 200 OK\r\n";
  // response += "Content-Type: multipart/x-mixed-replace; boundary=frame\r\n\r\n";
  // server.sendContent(response);

  // while (1)
  // {
  //     cam.run();
  //     if (!client.connected())
  //         break;
  //     response = "--frame\r\n";
  //     response += "Content-Type: image/jpeg\r\n\r\n";
  //     server.sendContent(response);

  //     client.write((char *)cam.getfb(), cam.getSize());
  //     server.sendContent("\r\n");
  //     if (!client.connected())
  //         break;
  // }
}

esp_err_t handle_jpg(PsychicRequest *request)
{  
  Serial.println("jpg");

    cam.run();
    // if (!client.connected())
    // {
    //     return;
    // }

    PsychicResponse response(request);
    response.setCode(200);
    response.setContentType("image/jpeg");   
    response.addHeader("Content-disposition","inline; filename=capture.jpg");    

    //add our actual content
    response.setContent((const uint8_t *)cam.getfb(), cam.getSize());
    return response.send();    
}


void setup()
{

  Serial.begin(115200);    

  int camInit =
  cam.init(esp32cam_aithinker_config);

  Serial.printf("Camera init returned %d\n", camInit);

  preferences.begin("credentials", false); 
  Serial.println("Reading from onboard Flash");

  String ssid = preferences.getString("ssid", ""); 
  String password = preferences.getString("password", "");

  Serial.println(ssid);

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.println("Connected");


  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  server.listen(80); // Must call listen() before registering any urls using .on()

  // We store the username and password for the OTA update side in Flash - i.e. so that when you wish to update the firmware for this board you need to have knowledge of the board specific OTA password
  String elegantUser = preferences.getString("elegantUser", ""); 
  String elegantPassword = preferences.getString("elegantPassword", ""); 

  Serial.println("OTA user: " + elegantUser);

  // Set Authentication Credentials
  ElegantOTA.setAuth(elegantUser.c_str(), elegantPassword.c_str());

  MultiClientHandler * persistentHandler =  new MultiClientHandler();

  // persistentHandler->handleRequest([](PsychicRequest *request)
  // {
  //   return ESP_OK;
  // });

  server.on("/str", HTTP_GET, persistentHandler);
  server.on("/stream", HTTP_GET, handle_jpg_stream);
  server.on("/jpg", HTTP_GET, handle_jpg);

  ElegantOTA.begin(&server);    // Start ElegantOTA

  // ElegantOTA callbacks
  ElegantOTA.onStart(onOTAStart);
  ElegantOTA.onProgress(onOTAProgress);
  ElegantOTA.onEnd(onOTAEnd);
  
  Serial.println("HTTP server started");

  rtspServer.begin();
}

CStreamer *streamer   = nullptr;
CRtspSession *session = nullptr;
WiFiClient client;      // FIXME, support multiple clients

void loop()
{
  ElegantOTA.loop();

  /// TODO
    // server.handleClient();

    uint32_t msecPerFrame = 100;
    static uint32_t lastimage = millis();

    // If we have an active client connection, just service that until gone
    // (FIXME - support multiple simultaneous clients)
    if(session) {
        session->handleRequests(0); // we don't use a timeout here,
        // instead we send only if we have new enough frames

        uint32_t now = millis();
        if(now > lastimage + msecPerFrame || now < lastimage) { // handle clock rollover
            session->broadcastCurrentFrame(now);
            lastimage = now;

            // check if we are overrunning our max frame rate
            now = millis();
            if(now > lastimage + msecPerFrame)
                printf("warning exceeding max frame rate of %d ms\n", now - lastimage);
        }

        if(session->m_stopped) {
            delete session;
            delete streamer;
            session = NULL;
            streamer = NULL;
        }
    }
    else {
        client = rtspServer.accept();

        if(client) {
            //streamer = new SimStreamer(&client, true);             // our streamer for UDP/TCP based RTP transport
            streamer = new OV2640Streamer(&client, cam);             // our streamer for UDP/TCP based RTP transport

            session = new CRtspSession(&client, streamer); // our threads RTSP session and state
        }
    }
}
